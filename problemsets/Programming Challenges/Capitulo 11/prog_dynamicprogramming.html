<html><head>


<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document"><title>Methods to Solve - Chapter 8. Dynamic Programming</title>

<meta content="Welcome to Steven Halim Website. It's me !!! It's my website" name="description">
<meta content="Steven, Halim, SH7" name="keywords"><!--mstheme-->
<link rel="stylesheet" type="text/css" href="prog_dynamicprogramming_arquivos/blen1010.css"><meta name="Microsoft Theme" content="blends 1010, default">
<meta name="Microsoft Border" content="t, default"></head><body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td>
<div align="center">
	<center>
	<table border="2" cellpadding="0" cellspacing="0" width="728">
		<tbody><tr>
			<td bgcolor="#ff6600" width="728">
			<p align="center"><font color="#ffffff">
			<a href="http://nus.edu.sg/">
			<img alt="NUS Home" src="prog_dynamicprogramming_arquivos/nuslogohome.gif" align="left" border="0" height="94" width="183"></a><strong><font face="Trebuchet MS" size="5">8. Dynamic Programming</font><font face="Trebuchet MS" size="2"><br>
			<nobr><a href="http://www.comp.nus.edu.sg/%7Estevenha/index.html" target="" style="text-decoration: none;">Home</a></nobr>&nbsp;|&nbsp;<nobr><a href="http://www.comp.nus.edu.sg/%7Estevenha/programming/programming.html" target="" style="text-decoration: none;">Up</a></nobr></font></strong></font></p></td>
		</tr>
	</tbody></table>
	</center></div>
</td></tr><!--msnavigation--></tbody></table><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><!--msnavigation--><td valign="top">

<center>
<script type="text/javascript"><!--
google_ad_client = "pub-5994970727713591";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_channel ="2643627799";
google_color_border = "B4D0DC";
google_color_bg = "ECF8FF";
google_color_link = "0000CC";
google_color_url = "008000";
google_color_text = "6F6F6F";
//--></script>
<script type="text/javascript" src="prog_dynamicprogramming_arquivos/show_ads.js">

</script><iframe name="google_ads_frame" src="prog_dynamicprogramming_arquivos/ads.htm" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" frameborder="0" height="90" scrolling="no" width="728"></iframe>
<table bgcolor="#fffff0" border="0" cellpadding="0" cellspacing="0" width="728">
	<tbody><tr>
		<td>
		<p style="margin-left: 10px; margin-right: 10px;" align="center">
		<font style="font-size: 8pt;" face="Verdana"><br>
		</font><font face="Verdana" size="2">Last updated on:
		<!--webbot bot="Timestamp" s-type="REGENERATED" s-format="%d %B %Y %I:%M:%S %p" startspan -->12 January 2007 04:40:08 PM<!--webbot bot="Timestamp" i-checksum="50813" endspan --></font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New"><span style="font-size: 10pt;">1.
		<a href="#1._Introduction_to_Dynamic_Programming">Introduction to Dynamic 
		Programming</a><br>
		2. </span></font><font style="font-size: 10pt;" face="Courier New">
		<a href="#2._Matrix_Chain_Multiplication_%28MCM%29">Matrix Chain Multiplication 
		(MCM)</a><br>
		3. <a href="#3._Longest_Common_Subsequence_%28LCS%29">Longest Common Subsequence 
		(LCS)</a><br>
		4. <a href="#4._Edit_Distance">Edit Distance</a><br>
		5. <a href="#5._Longest_Inc/Dec-reasing_Subsequence_%28LIS/LDS%29">Longest Inc/Dec-reasing 
		Subsequence (LIS/LDS)</a><br>
		6. <a href="#6._Zero-One_Knapsack">Zero-One Knapsack</a><br>
		7. <a href="#7._Counting_Change">Counting Change</a><br>
		8. <a href="#8._Maximum_Interval_Sum">Maximum Interval Sum</a><br>
		9. <a href="#9._Other_Dynamic_Programming_Algorithms">Other Dynamic Programming 
		Algorithms</a></font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana"><b><font class="desthdr" color="#000000" size="4">
		<a name="1._Introduction_to_Dynamic_Programming">1. Introduction to Dynamic 
		Programming</a></font></b></font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		Dynamic Programming (shortened as DP) is a programming technique that can 
		dramatically reduces the runtime of some algorithms (but not all problem 
		has DP characteristics) from exponential to polynomial. Many (and still 
		increasing) real world problems only solvable within reasonable time using 
		DP.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		To be able to use DP, the original problem must have:<br>
		1. <b><u>Optimal sub-structure</u></b> property:<br>
&nbsp;&nbsp;&nbsp; optimal solution to the problem contains within it optimal solutions 
		to sub-problems<br>
		2. <u><b>Overlapping sub-problems</b></u> property<br>
&nbsp;&nbsp;&nbsp; we accidentally recalculate the same problem twice or more.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		There are 2 types of DP: We can either build up solutions of sub-problems 
		from small to large (bottom up) or we can save results of solutions of sub-problems 
		in a table (top down + memoization).</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Let's start with a sample of </font>
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		Dynamic Programming (DP) technique. We will examine the simplest form of 
		overlapping sub-problems. Remember Fibonacci? A popular problem which creates 
		a lot of redundancy if you use standard recursion f<sub>n </sub>= f<sub>n-1</sub> 
		+ f<sub>n-2</sub>.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		Top-down Fibonacci DP solution will record the each Fibonacci calculation 
		in a table so it won't have to re-compute the value again when you need 
		it, a simple table-lookup is enough (memoization), whereas Bottom-up DP 
		solution will build the solution from smaller numbers.</font></p>
		<font color="#0000ff" size="2">
		</font><p style="margin-left: 10px; margin-right: 10px;" align="left">
<font color="#0000ff" size="2">		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		Now let's see the comparison between Non-DP solution versus DP solution 
		(both bottom-up and top-down), given in the C source code below, along with 
		the appropriate comments.</font></font><max; %d="" ,non_dp(z="" printf="" \n\n="" )="" this="" will="" be="" much="" faster="" than="" the="" first="" for="" (z="0;" z=""><max; memo[z="0;" for="" (z="1;" z=""><max; %d="" ,dp_top_down(z="" printf="" \n\n="" )="" this="" normally="" will="" be="" the="" fastest="" *="" for="" (z="0;" z=""><max; memo[z="0;" for="" (z="1;" z=""><max; z="" %d="" ,dp_bottom_up(z="" printf="" \n\n="" )="" }=""></max;></max;></max;></max;></max;></p><p></p>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">#include &lt;stdio.h&gt;</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">#define MAX 20 // to test with bigger 
			number, adjust this value</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">int memo[MAX]; // array to store the previous 
			calculations</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">// the slowest, unnecessary computation 
			is repeated<br>
			int Non_DP(int n) {<br>
&nbsp; if (n==1 || n==2)<br>
&nbsp;&nbsp;&nbsp; return 1;<br>
&nbsp; else<br>
&nbsp;&nbsp;&nbsp; return Non_DP(n-1) + Non_DP(n-2);<br>
			}</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">// top down DP<br>
			int DP_Top_Down(int n) {<br>
&nbsp; // base case<br>
&nbsp; if (n == 1 || n == 2)<br>
&nbsp;&nbsp;&nbsp; return 1;</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; // immediately return the previously 
			computed result<br>
&nbsp; if (memo[n] != 0)<br>
&nbsp;&nbsp;&nbsp; return memo[n];</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; // otherwise, do the same as Non_DP<br>
&nbsp; memo[n] = DP_Top_Down(n-1) + DP_Top_Down(n-2);<br>
&nbsp; return memo[n];<br>
			}</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">// fastest DP, bottom up, store the previous 
			results in array<br>
			int DP_Bottom_Up(int n) {<br>
&nbsp; memo[1] = memo[2] = 1; // default values for DP algorithm</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; // from 3 to n (we already know 
			that fib(1) and fib(2) = 1<br>
&nbsp; for (int i=3; i&lt;=n; i++)<br>
&nbsp;&nbsp;&nbsp; memo[i] = memo[i-1] + memo[i-2];</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; return memo[n];<br>
			}</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">void main() {<br>
&nbsp; int z;</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; // this will be the slowest<br>
&nbsp; for (z=1; z&lt;MAX; z++) printf("%d-",Non_DP(z));<br>
&nbsp; printf("\n\n");</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; // this will be much faster than 
			the first<br>
&nbsp; for (z=0; z&lt;MAX; z++) memo[z] = 0;<br>
&nbsp; for (z=1; z&lt;MAX; z++) printf("%d-",DP_Top_Down(z));<br>
&nbsp; printf("\n\n");</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font color="#000000" face="Courier New"><font class="desthdr">
			<font style="font-size: 10pt;">&nbsp; /* this normally will be the fastest 
			*/<br>
&nbsp; for (z=0; z&lt;MAX; z++) memo[z] = 0;<br>
&nbsp; for (z=1; z&lt;MAX; z++) printf("%d-",DP_Bottom_Up(z));<br>
&nbsp; printf("\n\n");<br>
			}</font></font></font></p>
		</div>
		<div align="left">
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font face="Verdana" size="2">You may be interested with another section 
			regarding Fibonacci in </font>
			<font color="#ffffff" face="Verdana" size="2">
			<a href="http://www.comp.nus.edu.sg/%7Estevenha/programming/prog_mathematics.html">math section</a></font><font face="Verdana" size="2">, 
			There is a faster O(log n) algorithm for computing Fibonacci :D summarized 
			there.</font></p>
		</div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><b><u>
		<font face="Verdana"><font class="desthdr" color="#000000" size="4">
		<a name="2._Matrix_Chain_Multiplication_(MCM)">2. Matrix Chain Multiplication 
		(MCM)</a></font></font></u></b></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Let's start by analyzing the cost of multiplying 
		2 matrices:</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">Matrix-Multiply(A,B):<br>
&nbsp; if columns[A] != columns[B] then<br>
&nbsp;&nbsp;&nbsp; error "incompatible dimensions"<br>
&nbsp; else<br>
&nbsp;&nbsp;&nbsp; for i = 1 to rows[A] do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for j = 1 to columns[B] do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C[i,j]=0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for k = 1 to columns[A] do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C[i,j] = C[i,j] + A[i,k] 
		* B[k,j]<br>
&nbsp; return C</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Time complexity = O(pqr) where |A|=p x q and 
		|B| = q x r</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">a1,1 a1,2 a1,3&nbsp;&nbsp; *&nbsp;&nbsp; 
		b1,1&nbsp; =&nbsp; c1,1<br>
		a2,1 a2,2 a2,3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2,1&nbsp;&nbsp;&nbsp;&nbsp; 
		c2,1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		b3,1</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">|A| = 2 * 3, |B| = 3 * 1, therefore to multiply 
		these 2 matrices, we need O(2*3*1)=O(6) <u><b>scalar multiplication</b></u>. 
		The result is matrix C with |C| = 2 * 1</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber2" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR MATRIX MULTIPLICATION KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with Matrix Multiplication:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v4/442.html">
						442 - Matrix Chain Multiplication</a> - Straightforward 
						problem</font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="2">Matrix Chain Multiplication Problem</font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Input</b></u>: Matrices A<sub>1</sub>,A<sub>2</sub>,...A<sub>n</sub>, 
		each A<sub>i </sub>of size P<sub>i-1</sub> x P<sub>i</sub><br>
		<u><b>Output</b></u>: Fully parenthesized product A<sub>1</sub>A<sub>2</sub>...A<sub>n</sub> 
		that <u><b>minimizes the number of scalar multiplications</b></u></font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">A product of matrices is fully parenthesized 
		if it is either<br>
		1. a single matrix<br>
		2. the product of 2 fully parenthesized matrix products surrounded by parentheses</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Example of MCM problem:<br>
		We have 3 matrices and the size of each matrix:<br>
		A<sub>1</sub> (10 x 100), A<sub>2</sub> (100 x 5), A<sub>3</sub> (5 x 50)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">We can fully parenthesized them in two ways:<br>
		1. (A<sub>1</sub> (A<sub>2</sub> A<sub>3</sub>)) = 100 x 5 x 50 + 10 * 100 
		* 50 = 75000<br>
		2. ((A<sub>1</sub> A<sub>2</sub>) A<sub>3</sub>) = 10 x 100 x 5 + 10 x 5 
		x 50 = 7500 (10 times better)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">See how the cost of multiplying these 3 matrices 
		differ significantly. The cost truly depend on the choice of the fully parenthesization 
		of the matrices. However, exhaustively checking all possible parenthesizations 
		take exponential time. (Proof: see CLR chapter 16)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Now let's see how MCM problem can be solved 
		using DP.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana" size="2">Step 1: characterize the optimal sub-structure 
		of this problem.</font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Let A<sub>i..j</sub> (i &lt; j) denote the result 
		of multiplying A<sub>i</sub>A<sub>i+1</sub>..A<sub>j</sub>.<br>
		A<sub>i..j</sub> can be obtained by splitting it into A<sub>i..k</sub> and 
		A<sub>k+1..j</sub> and then multiplying the sub-products. There are j-i 
		possible splits (i.e. k=i,...,j-1)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Within the optimal parenthesization of A<sub>i..j</sub> 
		:<br>
		(a) the parenthesization of A<sub>i..k</sub> must be optimal<br>
		(b) the parenthesization of A<sub>k+1..j</sub> must be optimal</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Because if they are not optimal, then there 
		exist other split which is better, and we should choose that split and not 
		this split.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana" size="2">Step 2: Recursive formulation</font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Need to find A<sub>1..n<br>
		</sub>Let m[i,j] = minimum number of scalar multiplications needed to compute 
		A<sub>i..j</sub></font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Since A<sub>i..j</sub> can be obtained by 
		breaking it into A<sub>i..k</sub> A<sub>k+1..j</sub>, we have<br>
		m[i,j] = 0, if i=j<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = min i&lt;=k&lt;j { m[i,k]+m[k+1,j]+p<sub>i-1</sub>p<sub>k</sub>p<sub>j</sub> 
		}, if i&lt;j</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">let s[i,j] be the value k where the optimal 
		split occurs.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana" size="2">Step 3 Computing the Optimal Costs</font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">Matric-Chain-Order(p)<br>
&nbsp; n = length[p]-1<br>
&nbsp; for i = 1 to n do<br>
&nbsp;&nbsp;&nbsp; m[i,i] = 0<br>
&nbsp; for l = 2 to n do<br>
&nbsp;&nbsp;&nbsp; for i = 1 to n-l+1 do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = i+l-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i,j] = infinity<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for k = i to j-1 do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = m[i,k] + m[k+1,j] + pi-1*pk*pj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if q &lt; m[i,j] then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[i,j] = q<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i,j] = k<br>
&nbsp; return m and s</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana" size="2">Step 4: Constructing an Optimal Solution</font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">Print-MCM(s,i,j)<br>
&nbsp; if i=j then<br>
&nbsp;&nbsp;&nbsp; print Ai<br>
&nbsp; else<br>
&nbsp;&nbsp;&nbsp; print "(" + Print-MCM(s,1,s[i,j]) + "*" + Print-MCM(s,s[i,j]+1,j) 
		+ ")"</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Note</b></u>: As any other DP solution, 
		MCM also can be solved using Top Down recursive algorithm using memoization. 
		Sometimes, if you cannot visualize the Bottom Up, approach, just modify 
		your original Top Down recursive solution by including memoization. You'll 
		save a lot of time by avoiding repetitive calculation of sub-problems. Details 
		of MCM problem can be found in CLR chapter 16.</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber3" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR MATRIX CHAIN MULTIPLICATION KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with Matrix Chain Multiplication:</font></p>
						<p align="left"><font face="Verdana" size="2">
						<a target="_top" href="http://acm.uva.es/p/v3/348.html">
						348 - Optimal Array Multiplication Sequence</a></font><font color="#ffffff" face="Verdana" size="2"> 
						- Use algorithm above</font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana"><font class="desthdr" color="#000000" size="4">
		<a name="3._Longest_Common_Subsequence_(LCS)">3. Longest Common Subsequence 
		(LCS)</a></font></font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="2">Longest Common Subsequence Problem:</font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana"><u><b>Input</b></u>: Two sequence<br>
		<u><b>Output</b></u>: A longest common subsequence of those two sequences, 
		see details below.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana">A sequence Z&nbsp; is a <b>
		subsequence</b> of X &lt;x</font><font face="Verdana" size="2"><sub>1</sub></font><font style="font-size: 10pt;" face="Verdana">,x</font><font face="Verdana" size="2"><sub>2</sub></font><font style="font-size: 10pt;" face="Verdana">,...,x</font><font face="Verdana" size="2"><sub>m</sub></font><font style="font-size: 10pt;" face="Verdana">&gt;, 
		if there exists a strictly increasing sequence &lt;i</font><font face="Verdana" size="2"><sub>1</sub></font><font style="font-size: 10pt;" face="Verdana">,i</font><font face="Verdana" size="2"><sub>2</sub></font><font style="font-size: 10pt;" face="Verdana">,...,i</font><font face="Verdana" size="2"><sub>k</sub></font><font style="font-size: 10pt;" face="Verdana">&gt; 
		of indices of X such that for all j=1,2,..,k, we have x</font><font face="Verdana" size="2"><sub>i</sub></font><font style="font-size: 10pt;" face="Verdana">=z</font><font face="Verdana" size="2"><sub>j</sub></font><font style="font-size: 10pt;" face="Verdana">. 
		example: X=&lt;B,C,A,D&gt; and Z=&lt;C,A&gt;.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana">A sequence Z is called <b>common 
		subsequence</b> of sequence X and Y if Z is subsequence of both X and Y.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana"><b>longest common subsequence 
		(LCS)</b> is just the longest "common subsequence" of two sequences.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana">A brute force approach of finding 
		LCS such as enumerating all subsequences and finding the longest common 
		one takes too much time. However, Computer Scientist has found a Dynamic 
		Programming solution for LCS problem. For details, you can refer to Introduction 
		to Algorithm chapter 16 (Dynamic Programming), I will only write the final 
		code here, written in C, ready to use. Note that this code is slightly modified 
		and I use global variables (yes this is not Object Oriented)...</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Courier New">// just copy &amp; paste this 
		code and test it yourself<br>
		<br>
		#include &lt;stdio.h&gt;<br>
		#include &lt;string.h&gt;<br>
		<br>
		// change this constant if you want a longer subsequence<br>
		#define MAX 100<br>
		<br>
		char X[MAX],Y[MAX];<br>
		int i,j,m,n,c[MAX][MAX],b[MAX][MAX];<br>
		<br>
		int LCSlength() {<br>
&nbsp; m=strlen(X);<br>
&nbsp; n=strlen(Y);<br>
		<br>
&nbsp; for (i=1;i&lt;=m;i++) c[i][0]=0;<br>
&nbsp; for (j=0;j&lt;=n;j++) c[0][j]=0;<br>
		<br>
&nbsp; for (i=1;i&lt;=m;i++)<br>
&nbsp;&nbsp;&nbsp; for (j=1;j&lt;=n;j++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (X[i-1]==Y[j-1]) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i][j]=c[i-1][j-1]+1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b[i][j]=1; /* from north west */<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (c[i-1][j]&gt;=c[i][j-1]) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i][j]=c[i-1][j];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b[i][j]=2; /* from north */<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i][j]=c[i][j-1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b[i][j]=3; /* from west */<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
&nbsp;&nbsp;&nbsp; }<br>
		<br>
&nbsp; return c[m][n];<br>
		}<br>
		<br>
		void printLCS(int i,int j) {<br>
&nbsp; if (i==0 || j==0) return;<br>
		<br>
&nbsp; if (b[i][j]==1) {<br>
&nbsp;&nbsp;&nbsp; printLCS(i-1,j-1);<br>
&nbsp;&nbsp;&nbsp; printf("%c",X[i-1]);<br>
&nbsp; }<br>
&nbsp; else if (b[i][j]==2)<br>
&nbsp;&nbsp;&nbsp; printLCS(i-1,j);<br>
&nbsp; else<br>
&nbsp;&nbsp;&nbsp; printLCS(i,j-1);<br>
		}</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Courier New">void main() {<br>
&nbsp; while (1) {<br>
&nbsp;&nbsp;&nbsp; gets(X);<br>
&nbsp;&nbsp;&nbsp; if (feof(stdin)) break; /* press ctrl+z to terminate */<br>
&nbsp;&nbsp;&nbsp; gets(Y);<br>
&nbsp;&nbsp;&nbsp; printf("LCS length -&gt; %d\n",LCSlength()); /* count length */<br>
&nbsp;&nbsp;&nbsp; printLCS(m,n); /* reconstruct LCS */<br>
&nbsp;&nbsp;&nbsp; printf("\n");<br>
&nbsp; }<br>
		}</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Question</b></u>: Can you list out ALL 
		possible LCS?<br>
		<u><b>Answer</b></u>: Modify printLCS(), details will be available later.</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber4" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR LONGEST COMMON SUBSEQUENCE KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with LCS:</font></p>
						<p align="left"><font face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v5/531.html">
						531 - Compromise</a><br>
						<a target="_blank" href="http://acm.uva.es/p/v100/10066.html">
						10066 - The Twin Towers</a></font><br>
						<font face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v101/10100.html">
						10100 - Longest Match</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v101/10192.html">
						10192 - Vacation</a></font><br>
						<font face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v104/10405.html">
						10405 - Longest Common Subsequence</a></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana"><b><font class="desthdr" color="#000000" size="4">
		<a name="4._Edit_Distance">4. Edit Distance</a></font></b></font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="2">Edit Distance Problem:</font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana"><u><b>Input</b></u>: Given 
		two string, Cost for deletion, insertion, and replace<br>
		<u><b>Output</b></u>: Give the minimum actions needed to transform first 
		string into the second one.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Edit Distance problem is a bit similar to 
		LCS. DP Solution for this problem is very useful in Computational Biology 
		such as for comparing DNA.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Let d(string1,string2) be the distance between 
		these 2 strings.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><b>
		<font face="Verdana" size="2">Recurrence Relation:</font></b></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">d("","") = 0<br>
		d(s ,"") = d("", s) = |s| ;; i.e. length of s<br>
		d(s1+ch1, s2+ch2)<br>
&nbsp; = min( d(s1, s2) + if (ch1==ch2) then 0 else 1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d(s1+ch1, s2) + 1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d(s1, s2+ch2) + 1 )</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Follow this
		<a target="_blank" href="http://www.csse.monash.edu.au/%7Elloyd/tildeAlgDS/Dynamic/Edit/">
		link</a> for more details. There is an applet there, you can try the algorithm 
		directly.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><b>
		<font face="Verdana" size="2">DP pseudo code:</font></b></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">A two-dimensional matrix, m[0..|s1|,0..|s2|] 
		is used to hold the edit distance values, such that m[i,j] = d(s1[1..i], 
		s2[1..j]).</font><br>
		<br>
		<font face="Courier New" size="2">m[0][0] = 0;<br>
		for (i=1; i&lt;length(s1); i++) m[i][0] = i;<br>
		for (j=1; j&lt;length(s2); j++) m[0][j] = j;</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">for (i=0; i&lt;length(s1); i++)<br>
&nbsp; for (j=0; j&lt;length(s2); j++) {<br>
&nbsp;&nbsp;&nbsp; val = (s1[i] == s2[j]) ? 0 : 1;<br>
&nbsp;&nbsp;&nbsp; m[i][j] = min( m[i-1][j-1] + val,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		min(m[i-1][j]+1 , m[i][j-1]+1));<br>
&nbsp; }</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">To output the trace, use another array to 
		store our action along the way. Trace back these values later.</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber8" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR EDIT DISTANCE KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with DP:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v1/164.html">
						164 - String Computer</a></font><font face="Verdana" size="2"><br>
						</font><font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v5/526.html">
						526 - String Distance and Edit Process</a><font color="#ffffff"> 
						- I haven't solve this...</font></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u>
		<font face="Verdana"><b><font class="desthdr" color="#000000" size="4">
		<a name="5._Longest_Inc/Dec-reasing_Subsequence_(LIS/LDS)">5. Longest Inc/Dec-reasing 
		Subsequence (LIS/LDS)</a></font></b></font></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Verdana"><u><b>Input</b></u>: Given 
		a sequence<br>
		<u><b>Output</b></u>: The longest subsequence of the given sequence such 
		that all values in this longest&nbsp; subsequence is strictly increasing/decreasing.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">O(N^2) DP solution for LIS problem (this code 
		check for increasing values):</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">for i = 1 to total-1<br>
&nbsp; for j = i+1 to total<br>
&nbsp;&nbsp;&nbsp; if height[j] &gt; height[i] then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if length[i] + 1 &gt; length[j] then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length[j] = length[i] + 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; predecessor[j] = i</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Example:<br>
		height sequence: 1,6,2,3,5<br>
		length initially: [1,1,1,1,1] - because max length is at least 1 rite...<br>
		predecessor initially: [nil,nil,nil,nil,nil] - assume no predecessor so 
		far</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">After first loop of j: <br>
&nbsp; length: [1,2,2,2,2], because 6,2,3,5 are all &gt; 1<br>
&nbsp; predecessor: [nil,1,1,1,1]<br>
		After second loop of j: (No change)<br>
&nbsp; length: [1,2,2,2,2], because 2,3,5 are all &lt; 6<br>
&nbsp; predecessor: [nil,1,1,1,1]<br>
		After third loop:<br>
&nbsp; length: [1,2,2,3,3], because 3,5 are all &gt; 2<br>
&nbsp; predecessor: [nil,1,1,3,3]<br>
		After fourth loop:<br>
&nbsp; length: [1,2,2,3,4], because 5 &gt; 3<br>
&nbsp; predecessor: [nil,1,1,3,4]</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">We can reconstruct the solution using recursion 
		and predecessor array. =)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">However, is O(n^2) is the best algorithm to 
		solve LIS/LDS ?</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Fortunately, the answer is no. There exist 
		an O(n log k) algorithm to compute LIS (for LDS, this is just a reversed-LIS), 
		where k is the size of the actual LIS.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">This algorithm use some invariant, where for 
		each longest subsequence with length l, it will terminate with value A[l]. 
		(Notice that by maintaining this invariant, array A will be naturally sorted...) 
		Subsequent insertion (you will only do n insertions, one number at one time) 
		will use binary search to find the appropriate position in this <u>sorted 
		array A</u> (guess... only log k right?). </font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">&nbsp;&nbsp; 0&nbsp; 1&nbsp; 2&nbsp; 3&nbsp; 
		4&nbsp; 5&nbsp; 6&nbsp; 7&nbsp; 8<br>
		a&nbsp;&nbsp;&nbsp; -7,10, 9, 2, 3, 8, 8, 1</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">A -i&nbsp; i, i, i, i, i, i, i, i (iteration 
		number, i = infinity)<br>
		A -i -7, i, i, i, i, i, i, i (1)<br>
		A -i -7,10, i, i, i, i, i, i (2)<br>
		A -i -7, 9, i, i, i, i, i, i (3)<br>
		A -i -7, 2, i, i, i, i, i, i (4)<br>
		A -i -7, 2, 3, i, i, i, i, i (5)<br>
		A -i -7, 2, 3, 8, i, i, i, i (6)<br>
		A -i -7, 2, 3, 8, i, i, i, i (7)<br>
		A -i -7, 1, 3, 8, i, i, i, i (8)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">You can see that the length of LIS is 4, which 
		is correct. To reconstruct the LIS, at each step, store the predecessor 
		array as in standard LIS + this time remember the actual values, since array 
		A only store the last element in the subsequence, not the actual values.</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber5" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR LONGEST INC/DEC-REASING SUBSEQUENCE KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with LIS/LDS:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v1/111.html">
						111 - History Grading</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v2/231.html">
						231 - Testing the CATCHER</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v4/481.html">
						481 - What Goes Up</a> - need O(n log k) LIS</font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v4/497.html">
						497 - Strategic Defense Initiative</a></font><br>
						<a target="_blank" href="http://acm.uva.es/p/v100/10051.html">
						<font face="Verdana" size="2">10051 - Tower of Cubes</font></a><br>
						<a target="_blank" href="http://acm.uva.es/p/v101/10131.html">
						<font face="Verdana" size="2">10131 - Is Bigger Smarter</font></a><br>
						<font face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v101/10154.html">
						10154 - Weights and Measures</a></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="4"><a name="6._Zero-One_Knapsack">6. Zero-One 
		Knapsack</a></font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Zero-One Knapsack Problem:</b></u><br>
		<b>Input</b>: N items, each with various Vi (Value) and Wi (Weight) and 
		max Knapsack size MW.<br>
		<b>Output</b>: Maximum value of items that one can carry, if he can either 
		take or not-take a particular item.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Let C[i][w] be the maximum value if the available 
		items are {X<sub>1</sub>,X<sub>2</sub>,...,X<sub>i</sub>} and the knapsack 
		size is w.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><b>
		<font face="Verdana" size="2">Recurrence Relation:</font></b></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">;; if i == 0 or w == 0 (if no item or 
		knapsack full), we can't take anything<br>
		C[i][w] = 0</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">;; if Wi &gt; w (this item too heavy for 
		our knapsack), skip this item<br>
		C[i][w] = C[i-1][w];</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">;; if Wi &lt;= w, take the maximum of "not-take" 
		or "take"<br>
		C[i][w] = max(C[i-1][w] , C[i-1][w-Wi]+Vi);</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">;; The solution can be found in C[N][W];</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><b>
		<font face="Verdana" size="2">DP pseudo code:</font></b></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Courier New" size="2">for (i=0;i&lt;=N ;i++) C[i][0] = 0;<br>
		for (w=0;w&lt;=MW;w++) C[0][w] = 0;<br>
		<br>
		for (i=1;i&lt;=N;i++)<br>
&nbsp; for (w=1;w&lt;=MW;w++) {<br>
&nbsp;&nbsp;&nbsp; if (Wi[i] &gt; w)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C[i][w] = C[i-1][w];<br>
&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C[i][w] = max(C[i-1][w] , C[i-1][w-Wi[i]]+Vi[i]);<br>
&nbsp; }<br>
		<br>
		output(C[N][MW]);</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><b>Note</b>: actually, top-down is faster 
		than bottom up in this problem since we unnecessarily compute too much thing 
		if MW is big.</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber9" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR 0-1 KNAPSACK KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with 0-1 Knapsack:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v101/10130.html">
						10130 - SuperSale</a></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana"><font class="desthdr" color="#000000" size="4">
		<a name="7._Counting_Change">7. Counting Change</a></font></font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="2">Counting Change Problem:</font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Input</b></u>: A list of denominations 
		and a value N to be changed with these denominations<br>
		<u><b>Output</b></u>: Number of ways to change N</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		Suppose you have coins of 1 cent, 5 cents and 10 cents. You are asked to 
		pay 16 cents, therefore you have to give 1 one cent, 1 five cents, and 1 
		ten cents. Counting Change algorithm can be used to determine how many ways 
		you can use to pay an amount of money.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		The number of ways to change amount A using N kinds of coins equals to:</font></p>
		<ol style="font-family: Verdana; font-size: 10pt;">
			<li>
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
			The number of ways to change amount A using all but the first kind of 
			coins, +</font></p>
			</li>
			<li>
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
			The number of ways to change amount A-D using all N kinds of coins, 
			where D is the denomination of the first kind of coin.</font></p>
			</li>
		</ol>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		The tree recursive process will gradually reduce the value of A, then using 
		this rule, we can determine how many ways to change coins.</font></p>
		<ol style="font-family: Verdana; font-size: 10pt;">
			<li>
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
			If A is exactly 0, we should count that as 1 way to make change.</font></p>
			</li>
			<li>
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
			If A is less than 0, we should count that as 0 ways to make change.</font></p>
			</li>
			<li>
			<p style="margin-left: 10px; margin-right: 10px;" align="left">
			<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
			If N kinds of coins is 0, we should count that as 0 ways to make change.</font></p>
			</li>
		</ol>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font class="desthdr" style="font-size: 10pt;" color="#000000" face="Verdana">
		And finally, this is the Dynamic Programming solution for Counting Change 
		problem (in C):</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Courier New">#include &lt;stdio.h&gt;<br>
		#define MAXTOTAL 10000<br>
		<br>
		// This can be very big... long long may not be enough and<br>
		// you may need to use Big Integer<br>
		long long nway[MAXTOTAL+1];</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font style="font-size: 10pt;" face="Courier New">// Assume we have 5 different 
		coins here<br>
		int coin[5] = { 50,25,10,5,1 };<br>
		<br>
		void main() {<br>
&nbsp; int i,j,n,v,c;<br>
&nbsp; scanf("%d",&amp;n);<br>
&nbsp; v = 5;<br>
&nbsp; nway[0] = 1;<br>
&nbsp; for (i=0; i&lt;v; i++) {<br>
&nbsp;&nbsp;&nbsp; c = coin[i];<br>
&nbsp;&nbsp;&nbsp; for (j=c; j&lt;=n; j++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nway[j] += nway[j-c];<br>
&nbsp; }<br>
&nbsp; printf("%lld\n",nway[n]);<br>
		}</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber6" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR COUNTING CHANGE KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with Counting Change:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v1/147.html">
						147 - Dollars</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v3/357.html">
						357 - Let Me Count The Ways</a><font color="#ffffff"> - 
						Must use Big Integer</font></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v6/674.html">
						674 - Coin Change</a></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="4"><a name="8._Maximum_Interval_Sum">8. Maximum 
		Interval Sum</a></font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="2">Maximum Interval Sum Problem:</font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2"><u><b>Input</b></u>: A sequence of integers<br>
		<u><b>Output</b></u>: A sum of an interval starting from index i to index 
		j (consecutive), this sum must be maximum among all possible sums.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Initially Sum[i..n] are the integers from 
		the input (individual number).</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Courier New" size="2">Sum[i] = Sum[start] + ... + Sum[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if sum from index 'start' to i 
		is &gt;= 0 <b>or</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sum[i], set start=i+1 (start new 
		interval)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if sum from index 'start' to 'i' 
		&lt; 0</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Verdana" size="2">The simple reasoning of this DP formulation 
		is as follows: if you have positive (or zero) sum, then this current sequence 
		can still be extended to a longer interval with bigger value or at least 
		similar value but longer interval... but if the partial sum is negative... 
		then there is no point to extend it further...</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Verdana" size="2">Example:</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Courier New" size="2">Numbers : -1 <b>6</b><br>
		Sum&nbsp;&nbsp;&nbsp;&nbsp; : -1 <b>6</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max sum</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Courier New" size="2">Numbers : 4 -5&nbsp; <b>4 -3&nbsp; 4&nbsp; 
		4 -4&nbsp; 4</b> -5<br>
		Sum&nbsp;&nbsp;&nbsp;&nbsp; : 4 -1&nbsp; <b>4&nbsp; 1&nbsp; 5&nbsp; 9&nbsp; 
		5&nbsp; 9</b>&nbsp; 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
stop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
max sum</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Courier New" size="2">Numbers : <b>-2</b> -3 -4<br>
		Sum&nbsp;&nbsp;&nbsp;&nbsp; : <b>-2</b> -3 -4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max sum, but negative... (this is the 
		maximum anyway)</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Verdana" size="2">So, just do a linear sweep from left to right, 
		accumulate the sum one element by one element, start new interval whenever 
		you encounter partial sum &lt; 0 (and record current best maximum interval 
		encountered so far)...</font></p>
		<p style="margin-left: 10px; margin-right: 10px;">
		<font face="Verdana" size="2">At the end, output the value of the maximum 
		intervals.</font></p>
		<div align="center">
			<table style="border-collapse: collapse; text-align: center;" id="table1" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR MAXIMUM INTERVAL SUM KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with Maximum Interval Sum:</font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v5/507.html">
						507 - Jill Rides Again</a></font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
		</div>
		<p style="margin-left: 10px; margin-right: 10px;" align="left"><u><b>
		<font face="Verdana" size="4">
		<a name="9._Other_Dynamic_Programming_Algorithms">9. Other Dynamic Programming 
		Algorithms</a></font></b></u></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Problems that can be solved using Floyd Warshall 
		and it's variant, which belong to the category all-pairs shortest path algorithm, 
		can be categorized as Dynamic Programming solution. Explanation regarding 
		Floyd Warshall can be found in <a href="http://www.comp.nus.edu.sg/%7Estevenha/programming/prog_graph6.html">Graph section</a> 
		of this website.</font></p>
		<p style="margin-left: 10px; margin-right: 10px;" align="left">
		<font face="Verdana" size="2">Other than that, there are a lot of ad hoc 
		problems that can utilize DP, just remember that when the problem that you 
		encountered exploits optimal sub-structure and repeating sub-problems, apply 
		DP techniques, it may be helpful. Good luck :)</font></p>
		<div align="center">
			<center>
			<table style="border-collapse: collapse; text-align: center;" id="AutoNumber10" bgcolor="#008000" border="1" cellpadding="0" cellspacing="0" width="550">
				<tbody><tr>
					<td width="100%">
					<p align="center"><b>
					<font color="#ffffff" face="Verdana" size="2"><br>
					TEST YOUR DP KNOWLEDGE</font></b></p>
					<blockquote>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">Solve UVa 
						problems related with Ad-Hoc DP<font color="#ffffff">:</font></font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v1/108.html">
						108 - Maximum Sum</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v8/836.html">
						836 - Largest Submatrix</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v100/10003.html">
						<span lang="zh-cn">10003 - </span>Cutting Sticks</a></font><br>
						<font color="#ffffff" face="Verdana" size="2">
						<a target="_blank" href="http://acm.uva.es/p/v104/10465.html">
						<span lang="zh-cn">10</span>465<span lang="zh-cn"> -
						</span>Homer Simpson</a></font></p>
						<p align="left">
						<font color="#ffffff" face="Verdana" size="2">There are 
						a lot more... try it yourself...</font></p>
					</blockquote>
					</td>
				</tr>
			</tbody></table>
			</center></div>
		<hr><font face="Verdana" size="1">
		<!--
  The contents of this file are printed by the pagecount program when it
  is invoked as a server-side include.  The following directives are
  available for including data from the statistics database:
 

	Percent sign:		  %
	Anchor URL/URI: 	  http://www.comp.nus.edu.sg/cgi-bin/pagecount?/~stevenha/programming/prog_dynamicprogramming.html, /cgi-bin/pagecount?/~stevenha/programming/prog_dynamicprogramming.html
	Current date/time: 	  23-Feb-07, 07:47:59 GMT-8
	Total number of days: 	  943rd, 943
	Elapsed number of days:   943rd, 943
	Document path/file name:  /home/s/stevenha/public_html/programming/prog_dynamicprogramming.html, prog_dynamicprogramming.html
	Total number of hosts: 	  11291st, 11291
	Last access date/time: 	  23-Feb-07, 06:24:49 GMT-8
	Total number of accesses: 20952nd, 20952
	Remote host/address: 	  cache3.pop.com.br, 200.139.115.16
	Start date/time:	  26-Jul-04, 20:31:35 GMT-8
	Accesses today: 	  9th, 9
	Document URL/URI: 	  http://www.comp.nus.edu.sg/~stevenha/programming/prog_dynamicprogramming.html, /~stevenha/programming/prog_dynamicprogramming.html
	Accesses this host: 	  1st, 1

  The rest of the file should contain valid HTML.
-->

This document, <i>prog_dynamicprogramming.html</i>, has been accessed 20952 times since 26-Jul-04 20:31:35 GMT-8.
This is the 9th time it has been accessed today.
</font><p>
<font face="Verdana" size="1">A total of 11291 different hosts have accessed this document in the
last 943 days; your host, <i>cache3.pop.com.br</i>, has accessed it 1 times.
</font></p><p>
<font face="Verdana" size="1">If you're interested, <a href="http://www.comp.nus.edu.sg/cgi-bin/pagecount?/%7Estevenha/programming/prog_dynamicprogramming.html">complete statistics</a> for
this document are also available, including breakdowns by top-level
domain, host name, and date.
</font></p><p>
</p></td>
	</tr>
</tbody></table>
</center>

<!--msnavigation--></td></tr><!--msnavigation--></tbody></table></body></html>